<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
  <head>
    <title>第九章 JS的类</title>
    <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
    <meta content="" name="description"/>
    <meta content="GitBook 3.2.2" name="generator"/>
    <meta content="sagittarius-rev" name="author"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
        
<div class="page">
    
        <h1 class="book-chapter" id="calibre_toc_11">第九章 JS的类</h1>
        <div class="section">
            <h2 id="第九章-js的类" class="calibre12"><span id="introducing-javascript-classes" class="calibre13">第九章 JS的类</span></h2>
<p class="calibre6">与大多数正规的面向对象编程语言不同， JS 从创建之初就不支持类，也没有把类继承作为定义相似对象以及关联对象的主要方式，这让不少开发者感到困惑。而从 ES1 诞生之前直到 ES5 时期，很多库都创建了一些工具，让 JS 从表面看来仿佛能支持类。尽管一些 JS 开发者强烈认为这门语言不需要类，但为处理类而创建的代码库如此之多，导致 ES6 最终引入了类。</p>
<p class="calibre6">在探索 ES6 的类的过程中，理解类的潜在机制会很有帮助，因此本章将会首先讨论 ES5 的开发者如何实现对类行为的模仿。然而正如你将在后面看到的， ES6 的类并不与其他语言的类完全相同，所具备的独特性正配合了 JS 的动态本质。</p>
<ul class="calibre9">
<li class="calibre10"><a href="#class-like-structures-in-ecmascript-5" class="calibre7 pcalibre pcalibre1 pcalibre2">ES5 中的仿类结构</a></li>
<li class="calibre10"><a href="#class-declarations" class="calibre7 pcalibre pcalibre1 pcalibre2">类的声明</a><ul class="calibre14">
<li class="calibre10"><a href="#a-basic-class-declaration" class="calibre7 pcalibre pcalibre1 pcalibre2">基本的类声明</a></li>
<li class="calibre10"><a href="#why-to-use-the-class-syntax" class="calibre7 pcalibre pcalibre1 pcalibre2">为何要使用类的语法</a></li>
</ul>
</li>
<li class="calibre10"><a href="#class-expressions" class="calibre7 pcalibre pcalibre1 pcalibre2">类表达式</a><ul class="calibre14">
<li class="calibre10"><a href="#a-basic-class-expression" class="calibre7 pcalibre pcalibre1 pcalibre2">基本的类表达式</a></li>
<li class="calibre10"><a href="#named-class-expressions" class="calibre7 pcalibre pcalibre1 pcalibre2">具名类表达式</a></li>
</ul>
</li>
<li class="calibre10"><a href="#classes-as-first-class-citizens" class="calibre7 pcalibre pcalibre1 pcalibre2">作为一级公民的类</a></li>
<li class="calibre10"><a href="#accessor-properties" class="calibre7 pcalibre pcalibre1 pcalibre2">访问器属性</a></li>
<li class="calibre10"><a href="#computed-member-names" class="calibre7 pcalibre pcalibre1 pcalibre2">需计算的成员名</a></li>
<li class="calibre10"><a href="#generator-methods" class="calibre7 pcalibre pcalibre1 pcalibre2">生成器方法</a></li>
<li class="calibre10"><a href="#static-members" class="calibre7 pcalibre pcalibre1 pcalibre2">静态成员</a></li>
<li class="calibre10"><a href="#inheritance-with-derived-classes" class="calibre7 pcalibre pcalibre1 pcalibre2">使用派生类进行继承</a><ul class="calibre14">
<li class="calibre10"><a href="#shadowing-class-methods" class="calibre7 pcalibre pcalibre1 pcalibre2">屏蔽类方法</a></li>
<li class="calibre10"><a href="#inherited-static-members" class="calibre7 pcalibre pcalibre1 pcalibre2">继承静态成员</a></li>
<li class="calibre10"><a href="#derived-classes-from-expressions" class="calibre7 pcalibre pcalibre1 pcalibre2">从表达式中派生类</a></li>
<li class="calibre10"><a href="#inheriting-from-built-ins" class="calibre7 pcalibre pcalibre1 pcalibre2">继承内置对象</a></li>
<li class="calibre10"><a href="#the-symbol-species-property" class="calibre7 pcalibre pcalibre1 pcalibre2">Symbol.species 属性</a></li>
</ul>
</li>
<li class="calibre10"><a href="#using-new-target-in-class-constructors" class="calibre7 pcalibre pcalibre1 pcalibre2">在类构造器中使用 new.target</a></li>
<li class="calibre10"><a href="#summary" class="calibre7 pcalibre pcalibre1 pcalibre2">总结</a></li>
</ul>
<h3 id="es5-中的仿类结构" class="calibre15"><span id="class-like-structures-in-ecmascript-5" class="calibre13">ES5 中的仿类结构</span></h3>
<p class="calibre6">JS 在 ES5 及更早版本中都不存在类。与类最接近的是：创建一个构造器，然后将方法指派到该构造器的原型上。这种方式通常被称为创建一个自定义类型。例如：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PersonType</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">this</span>.name = name;
}

PersonType.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-params">console</span>.log(<span class="hljs-keyword">this</span>.name);
};

<span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> PersonType(<span class="hljs-string">"Nicholas"</span>);
person.sayName();   <span class="hljs-title">// 输出 "Nicholas"</span>

<span class="hljs-params">console</span>.log(person <span class="hljs-keyword">instanceof</span> PersonType);  <span class="hljs-title">// true</span>
<span class="hljs-params">console</span>.log(person <span class="hljs-keyword">instanceof</span> <span class="hljs-params">Object</span>);      <span class="hljs-title">// true</span>
</code></pre>
<p class="calibre6">此代码中的 <code class="pcalibre3 calibre11 pcalibre4">PersonType</code> 是一个构造器函数，并创建了单个属性 <code class="pcalibre3 calibre11 pcalibre4">name</code> 。 <code class="pcalibre3 calibre11 pcalibre4">sayName()</code> 方法被指派到原型上，因此在 <code class="pcalibre3 calibre11 pcalibre4">PersonType</code> 对象的所有实例上都共享了此方法。接下来，使用 <code class="pcalibre3 calibre11 pcalibre4">new</code> 运算符创建了 <code class="pcalibre3 calibre11 pcalibre4">PersonType</code> 的一个新实例 <code class="pcalibre3 calibre11 pcalibre4">person</code> ，此对象会被认为是一个通过原型继承了 <code class="pcalibre3 calibre11 pcalibre4">PersonType</code> 与 <code class="pcalibre3 calibre11 pcalibre4">Object</code> 的实例。</p>
<p class="calibre6">这种基本模式在许多对类进行模拟的 JS 库中都存在，而这也是 ES6 类的出发点。</p>
<h3 id="类的声明" class="calibre15"><span id="class-declarations" class="calibre13">类的声明</span></h3>
<p class="calibre6">类在 ES6 中最简单的形式就是类声明，它看起来很像其他语言中的类。</p>
<h4 id="基本的类声明" class="calibre15"><span id="a-basic-class-declaration" class="calibre13">基本的类声明</span></h4>
<p class="calibre6">类声明以 <code class="pcalibre3 calibre11 pcalibre4">class</code> 关键字开始，其后是类的名称；剩余部分的语法看起来就像对象字面量中的方法简写，并且在方法之间不需要使用逗号。作为范例，此处有个简单的类声明：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonClass</span> </span>{

    <span class="hljs-title">// 等价于 PersonType 构造器</span>
    <span class="hljs-keyword">constructor</span>(name) {
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-title">// 等价于 PersonType.prototype.sayName</span>
    sayName() {
        <span class="hljs-params">console</span>.log(<span class="hljs-keyword">this</span>.name);
    }
}

<span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> PersonClass(<span class="hljs-string">"Nicholas"</span>);
person.sayName();   <span class="hljs-title">// 输出 "Nicholas"</span>

<span class="hljs-params">console</span>.log(person <span class="hljs-keyword">instanceof</span> PersonClass);     <span class="hljs-title">// true</span>
<span class="hljs-params">console</span>.log(person <span class="hljs-keyword">instanceof</span> <span class="hljs-params">Object</span>);          <span class="hljs-title">// true</span>

<span class="hljs-params">console</span>.log(<span class="hljs-keyword">typeof</span> PersonClass);                    <span class="hljs-title">// "function"</span>
<span class="hljs-params">console</span>.log(<span class="hljs-keyword">typeof</span> PersonClass.prototype.sayName);  <span class="hljs-title">// "function"</span>
</code></pre>
<p class="calibre6">这个 <code class="pcalibre3 calibre11 pcalibre4">PersonClass</code> 类声明的行为非常类似上个例子中的 <code class="pcalibre3 calibre11 pcalibre4">PersonType</code> 。类声明允许你在其中使用特殊的 <code class="pcalibre3 calibre11 pcalibre4">constructor</code> 方法名称直接定义一个构造器，而不需要先定义一个函数再把它当作构造器使用。由于类的方法使用了简写语法，于是就不再需要使用 <code class="pcalibre3 calibre11 pcalibre4">function</code> 关键字。 <code class="pcalibre3 calibre11 pcalibre4">constructor</code> 之外的方法名称则没有特别的含义，因此可以随你高兴自由添加方法。</p>
<blockquote class="calibre20">
<p class="calibre6"><strong class="calibre8">自有属性</strong>（ <strong class="calibre8">Own properties</strong> ）：该属性出现在实例上而不是原型上，只能在类的构造器或方法内部进行创建。在本例中， <code class="pcalibre3 calibre11 pcalibre4">name</code> 就是一个自有属性。我建议应在构造器函数内创建所有可能出现的自有属性，这样在类中声明变量就会被限制在单一位置（有助于代码检查）。</p>
</blockquote>
<p class="calibre6">有趣的是，相对于已有的自定义类型声明方式来说，类声明仅仅是以它为基础的一个语法糖。 <code class="pcalibre3 calibre11 pcalibre4">PersonClass</code> 声明实际上创建了一个拥有 <code class="pcalibre3 calibre11 pcalibre4">constructor</code> 方法及其行为的函数，这也是 <code class="pcalibre3 calibre11 pcalibre4">typeof PersonClass</code> 会得到 <code class="pcalibre3 calibre11 pcalibre4">"function"</code> 结果的原因。此例中的 <code class="pcalibre3 calibre11 pcalibre4">sayName()</code> 方法最终也成为 <code class="pcalibre3 calibre11 pcalibre4">PersonClass.prototype</code> 上的一个方法，类似于上个例子中 <code class="pcalibre3 calibre11 pcalibre4">sayName()</code> 与 <code class="pcalibre3 calibre11 pcalibre4">PersonType.prototype</code> 之间的关系。这些相似处允许你把自定义类型与类混合使用，而不必太担忧到底该用哪个。</p>
<h4 id="为何要使用类的语法" class="calibre15"><span id="why-to-use-the-class-syntax" class="calibre13">为何要使用类的语法</span></h4>
<p class="calibre6">尽管类与自定义类型之间有相似性，但仍然要记住一些重要的区别：</p>
<ol class="calibre2">
<li class="calibre10">类声明不会被提升，这与函数定义不同。类声明的行为与 <code class="pcalibre3 calibre11 pcalibre4">let</code> 相似，因此在程序的执行到达声明处之前，类会存在于暂时性死区内。</li>
<li class="calibre10">类声明中的所有代码会自动运行在严格模式下，并且也无法退出严格模式。</li>
<li class="calibre10">类的所有方法都是不可枚举的，这是对于自定义类型的显著变化，后者必须用 <code class="pcalibre3 calibre11 pcalibre4">Object.defineProperty()</code> 才能将方法改变为不可枚举。</li>
<li class="calibre10">类的所有方法内部都没有 <code class="pcalibre3 calibre11 pcalibre4">[[Construct]]</code> ，因此使用 <code class="pcalibre3 calibre11 pcalibre4">new</code> 来调用它们会抛出错误。</li>
<li class="calibre10">调用类构造器时不使用 <code class="pcalibre3 calibre11 pcalibre4">new</code> ，会抛出错误。</li>
<li class="calibre10">试图在类的方法内部重写类名，会抛出错误。</li>
</ol>
<p class="calibre6">这样看来，上例中的 <code class="pcalibre3 calibre11 pcalibre4">PersonClass</code> 声明实际上就直接等价于以下未使用类语法的代码：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-title">// 直接等价于 PersonClass</span>
<span class="hljs-keyword">let</span> PersonType2 = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="calibre19">
    "use strict"</span>;

    <span class="hljs-keyword">const</span> PersonType2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{

        <span class="hljs-title">// 确认函数被调用时使用了 new</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span>.target === <span class="hljs-string">"undefined"</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-params">Error</span>(<span class="hljs-string">"Constructor must be called with new."</span>);
        }

        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-params">Object</span>.defineProperty(PersonType2.prototype, <span class="hljs-string">"sayName"</span>, {
        value: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

            <span class="hljs-title">// 确认函数被调用时没有使用 new</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span>.target !== <span class="hljs-string">"undefined"</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-params">Error</span>(<span class="hljs-string">"Method cannot be called with new."</span>);
            }

            <span class="hljs-params">console</span>.log(<span class="hljs-keyword">this</span>.name);
        },
        enumerable: <span class="hljs-params">false</span>,
        writable: <span class="hljs-params">true</span>,
        configurable: <span class="hljs-params">true</span>
    });

    <span class="hljs-keyword">return</span> PersonType2;
}());
</code></pre>
<p class="calibre6">首先要注意这里有两个 <code class="pcalibre3 calibre11 pcalibre4">PersonType2</code> 声明：一个在外部作用域的 <code class="pcalibre3 calibre11 pcalibre4">let</code> 声明，一个在 IIFE 内部的 <code class="pcalibre3 calibre11 pcalibre4">const</code> 声明。这就是为何类的方法不能对类名进行重写、而类外部的代码则被允许。构造器函数检查了 <code class="pcalibre3 calibre11 pcalibre4">new.target</code> ，以保证被调用时使用了 <code class="pcalibre3 calibre11 pcalibre4">new</code> ，否则就抛出错误。接下来， <code class="pcalibre3 calibre11 pcalibre4">sayName()</code> 方法被定义为不可枚举，并且此方法也检查了 <code class="pcalibre3 calibre11 pcalibre4">new.target</code> ，它则要保证在被调用时没有使用 <code class="pcalibre3 calibre11 pcalibre4">new</code> 。最后一步是将构造器函数返回出去。</p>
<p class="calibre6">此例说明了尽管不使用新语法也能实现类的任何特性，但类语法显著简化了所有功能的代码。</p>
<blockquote class="calibre20">
<p class="calibre6"><strong class="calibre8">不变的类名</strong></p>
<p class="calibre6">只有在类的内部，类名才被视为是使用 <code class="pcalibre3 calibre11 pcalibre4">const</code> 声明的。这意味着你可以在外部重写类名，但不能在类的方法内部这么做。例如：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
      Foo = <span class="hljs-string">"bar"</span>;    <span class="hljs-title">// 执行时抛出错误</span>
  }
}

<span class="hljs-title">// 但在类声明之后没问题</span>
Foo = <span class="hljs-string">"baz"</span>;
</code></pre>
<p class="calibre6">在此代码中，类构造器内部的 <code class="pcalibre3 calibre11 pcalibre4">Foo</code> 与在类外部的 <code class="pcalibre3 calibre11 pcalibre4">Foo</code> 是不同的绑定。内部的 <code class="pcalibre3 calibre11 pcalibre4">Foo</code> 就像是用 <code class="pcalibre3 calibre11 pcalibre4">const</code> 定义的，不能被重写，当构造器尝试使用任何值重写 <code class="pcalibre3 calibre11 pcalibre4">Foo</code> 时，都会抛出错误。但由于外部的 <code class="pcalibre3 calibre11 pcalibre4">Foo</code> 就像是用 <code class="pcalibre3 calibre11 pcalibre4">let</code> 声明的，你可以随时重写类名。</p>
</blockquote>
<h3 id="类表达式" class="calibre15"><span id="class-expressions" class="calibre13">类表达式</span></h3>
<p class="calibre6">类与函数有相似之处，即它们都有两种形式：声明与表达式。函数声明与类声明都以适当的关键词为起始（分别是 <code class="pcalibre3 calibre11 pcalibre4">function</code> 与 <code class="pcalibre3 calibre11 pcalibre4">class</code> ），随后是标识符（即函数名或类名）。函数具有一种表达式形式，无须在 <code class="pcalibre3 calibre11 pcalibre4">function</code> 后面使用标识符；类似的，类也有不需要标识符的表达式形式。<strong class="calibre8">类表达式</strong>被设计用于变量声明，或可作为参数传递给函数。</p>
<h4 id="基本的类表达式" class="calibre15"><span id="a-basic-class-expression" class="calibre13">基本的类表达式</span></h4>
<p class="calibre6">此处是与上例中的 <code class="pcalibre3 calibre11 pcalibre4">PersonClass</code> 等效的类表达式，随后的代码使用了它：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-keyword">let</span> PersonClass = <span class="calibre19"><span class="hljs-keyword">class</span> </span>{

    <span class="hljs-title">// 等价于 PersonType 构造器</span>
    <span class="hljs-keyword">constructor</span>(name) {
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-title">// 等价于 PersonType.prototype.sayName</span>
    sayName() {
        <span class="hljs-params">console</span>.log(<span class="hljs-keyword">this</span>.name);
    }
};

<span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> PersonClass(<span class="hljs-string">"Nicholas"</span>);
person.sayName();   <span class="hljs-title">// 输出 "Nicholas"</span>

<span class="hljs-params">console</span>.log(person <span class="hljs-keyword">instanceof</span> PersonClass);     <span class="hljs-title">// true</span>
<span class="hljs-params">console</span>.log(person <span class="hljs-keyword">instanceof</span> <span class="hljs-params">Object</span>);          <span class="hljs-title">// true</span>

<span class="hljs-params">console</span>.log(<span class="hljs-keyword">typeof</span> PersonClass);                    <span class="hljs-title">// "function"</span>
<span class="hljs-params">console</span>.log(<span class="hljs-keyword">typeof</span> PersonClass.prototype.sayName);  <span class="hljs-title">// "function"</span>
</code></pre>
<p class="calibre6">正如此例所示，类表达式不需要在 <code class="pcalibre3 calibre11 pcalibre4">class</code> 关键字后使用标识符。除了语法差异，类表达式的功能等价于类声明。</p>
<p class="calibre6">在匿名的类表达式内 <code class="pcalibre3 calibre11 pcalibre4">PersonClass.name</code> 是个空的字符串。而若使用了类声明，则 <code class="pcalibre3 calibre11 pcalibre4">PersonClass.name</code> 就会是 <code class="pcalibre3 calibre11 pcalibre4">"PersonClass"</code> 。</p>
<blockquote class="calibre20">
<p class="calibre6">使用类声明还是类表达式，主要是代码风格问题。相对于函数声明与函数表达式之间的区别，类声明与类表达式都不会被提升，因此对代码运行时的行为影响甚微。唯一显著的差异是匿名类表达式的 <code class="pcalibre3 calibre11 pcalibre4">name</code> 属性是一个空字符串，而类声明的 <code class="pcalibre3 calibre11 pcalibre4">name</code> 属性则与类名相同（例如，使用类声明时， <code class="pcalibre3 calibre11 pcalibre4">PersonClass.name</code> 的值为 <code class="pcalibre3 calibre11 pcalibre4">"PersonClass"</code> ）。</p>
</blockquote>
<hr class="pcalibre8 pcalibre7 calibre24"/>
<blockquote class="calibre20">
<p class="calibre6"><strong class="calibre8">译注：</strong>测试发现匿名类表达式的名称只在 FireFox 中才是空字符串，而其他浏览器都会使用表达式赋值目标的变量的名称。（该测试由 <strong class="calibre8">oshotokill</strong> 提供）</p>
</blockquote>
<h4 id="具名类表达式" class="calibre15"><span id="named-class-expressions" class="calibre13">具名类表达式</span></h4>
<p class="calibre6">上一节的示例使用了一个匿名的类表达式，不过就像函数表达式那样，你也可以为类表达式命名。为此需要在 <code class="pcalibre3 calibre11 pcalibre4">class</code> 关键字后添加标识符，就像这样：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-keyword">let</span> PersonClass = <span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonClass2</span> </span>{

    <span class="hljs-title">// 等价于 PersonType 构造器</span>
    <span class="hljs-keyword">constructor</span>(name) {
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-title">// 等价于 PersonType.prototype.sayName</span>
    sayName() {
        <span class="hljs-params">console</span>.log(<span class="hljs-keyword">this</span>.name);
    }
};

<span class="hljs-params">console</span>.log(<span class="hljs-keyword">typeof</span> PersonClass);        <span class="hljs-title">// "function"</span>
<span class="hljs-params">console</span>.log(<span class="hljs-keyword">typeof</span> PersonClass2);       <span class="hljs-title">// "undefined"</span>
</code></pre>
<p class="calibre6">此例中的类表达式被命名为 <code class="pcalibre3 calibre11 pcalibre4">PersonClass2</code> 。 <code class="pcalibre3 calibre11 pcalibre4">PersonClass2</code> 标识符只在类定义内部存在，因此只能用在类方法内部（例如本例的 <code class="pcalibre3 calibre11 pcalibre4">sayName()</code> 内）。在类的外部， <code class="pcalibre3 calibre11 pcalibre4">typeof PersonClass2</code> 的结果为 <code class="pcalibre3 calibre11 pcalibre4">"undefined"</code> ，这是因为外部不存在 <code class="pcalibre3 calibre11 pcalibre4">PersonClass2</code> 绑定。要理解为何如此，请查看未使用类语法的等价声明：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-title">// 直接等价于 PersonClass 具名的类表达式</span>
<span class="hljs-keyword">let</span> PersonClass = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="calibre19">
    "use strict"</span>;

    <span class="hljs-keyword">const</span> PersonClass2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{

        <span class="hljs-title">// 确认函数被调用时使用了 new</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span>.target === <span class="hljs-string">"undefined"</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-params">Error</span>(<span class="hljs-string">"Constructor must be called with new."</span>);
        }

        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-params">Object</span>.defineProperty(PersonClass2.prototype, <span class="hljs-string">"sayName"</span>, {
        value: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

            <span class="hljs-title">// 确认函数被调用时没有使用 new</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span>.target !== <span class="hljs-string">"undefined"</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-params">Error</span>(<span class="hljs-string">"Method cannot be called with new."</span>);
            }

            <span class="hljs-params">console</span>.log(<span class="hljs-keyword">this</span>.name);
        },
        enumerable: <span class="hljs-params">false</span>,
        writable: <span class="hljs-params">true</span>,
        configurable: <span class="hljs-params">true</span>
    });

    <span class="hljs-keyword">return</span> PersonClass2;
}());
</code></pre>
<p class="calibre6">创建具名的类表达式稍微改变了在 JS 引擎内部发生的事。对于类声明来说，外部绑定（用 <code class="pcalibre3 calibre11 pcalibre4">let</code> 定义）与内部绑定（用 <code class="pcalibre3 calibre11 pcalibre4">const</code> 定义）有着相同的名称。而类表达式可在内部使用 <code class="pcalibre3 calibre11 pcalibre4">const</code> 来定义它的不同名称，因此此处的 <code class="pcalibre3 calibre11 pcalibre4">PersonClass2</code> 只能在类的内部使用。</p>
<p class="calibre6">尽管具名类表达式的行为异于具名函数表达式，但它们之间仍然有许多相似点。二者都能被当作值来使用，这开启了许多可能性，接下来我将会对此进行介绍。</p>
<h3 id="作为一级公民的类" class="calibre15"><span id="classes-as-first-class-citizens" class="calibre13">作为一级公民的类</span></h3>
<p class="calibre6">在编程中，能被当作值来使用的就称为<strong class="calibre8">一级公民</strong>（ <strong class="calibre8">first-class citizen</strong> ），意味着它能作为参数传给函数、能作为函数返回值、能用来给变量赋值。 JS的函数就是一级公民（它们有时又被称为一级函数），此特性让 JS 独一无二。</p>
<p class="calibre6">ES6 延续了传统，让类同样成为一级公民。这就使得类可以被多种方式所使用。例如，它能作为参数传入函数：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createObject</span>(<span class="hljs-params">classDef</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> classDef();
}

<span class="hljs-keyword">let</span> obj = createObject(<span class="calibre19"><span class="hljs-keyword">class</span> </span>{

    sayHi() {
        <span class="hljs-params">console</span>.log(<span class="hljs-string">"Hi!"</span>);
    }
});

obj.sayHi();        <span class="hljs-title">// "Hi!"</span>
</code></pre>
<p class="calibre6">此例中的 <code class="pcalibre3 calibre11 pcalibre4">createObject()</code> 函数被调用时接收了一个匿名类表达式作为参数，使用 <code class="pcalibre3 calibre11 pcalibre4">new</code> 创建了该类的一个实例，并将其返回出来。随后变量 <code class="pcalibre3 calibre11 pcalibre4">obj</code> 储存了所返回的实例。</p>
<p class="calibre6">类表达式的另一个有趣用途是立即调用类构造器，以创建单例（ Singleton ）。为此，你必须使用 <code class="pcalibre3 calibre11 pcalibre4">new</code> 来配合类表达式，并在表达式后面添加括号。例如：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="calibre19"><span class="hljs-keyword">class</span> </span>{

    <span class="hljs-keyword">constructor</span>(name) {
        <span class="hljs-keyword">this</span>.name = name;
    }

    sayName() {
        <span class="hljs-params">console</span>.log(<span class="hljs-keyword">this</span>.name);
    }

}(<span class="hljs-string">"Nicholas"</span>);

person.sayName();       <span class="hljs-title">// "Nicholas"</span>
</code></pre>
<p class="calibre6">此处创建了一个匿名类表达式，并立即执行了它。此模式允许你使用类语法来创建单例，从而不留下任何可被探查的类引用（回忆一下 <code class="pcalibre3 calibre11 pcalibre4">PersonClass</code> 的例子，匿名类表达式只在类的内部创建了绑定，而外部无绑定）。类表达式后面的圆括号表示要调用前面的函数，并且还允许传入参数。</p>
<p class="calibre6">本章至今的例子都集中于带有方法的类，但你还能在类上创建访问器属性，所用的语法类似于对象字面量。</p>
<h3 id="访问器属性" class="calibre15"><span id="accessor-properties" class="calibre13">访问器属性</span></h3>
<p class="calibre6">自有属性需要在类构造器中创建，而类还允许你在原型上定义访问器属性。为了创建一个 getter ，要使用 <code class="pcalibre3 calibre11 pcalibre4">get</code> 关键字，并要与后方标识符之间留出空格；创建 setter 用相同方式，只是要换用 <code class="pcalibre3 calibre11 pcalibre4">set</code> 关键字。例如：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomHTMLElement</span> </span>{

    <span class="hljs-keyword">constructor</span>(element) {
        <span class="hljs-keyword">this</span>.element = element;
    }

    get html() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.element.innerHTML;
    }

    set html(value) {
        <span class="hljs-keyword">this</span>.element.innerHTML = value;
    }
}

<span class="hljs-keyword">var</span> descriptor = <span class="hljs-params">Object</span>.getOwnPropertyDescriptor(CustomHTMLElement.prototype, <span class="hljs-string">"html"</span>);
<span class="hljs-params">console</span>.log(<span class="hljs-string">"get"</span> <span class="hljs-keyword">in</span> descriptor);   <span class="hljs-title">// true</span>
<span class="hljs-params">console</span>.log(<span class="hljs-string">"set"</span> <span class="hljs-keyword">in</span> descriptor);   <span class="hljs-title">// true</span>
<span class="hljs-params">console</span>.log(descriptor.enumerable); <span class="hljs-title">// false</span>
</code></pre>
<p class="calibre6">此代码中的 <code class="pcalibre3 calibre11 pcalibre4">CustomHTMLElement</code> 类用于包装一个已存在的 DOM 元素。它的属性 <code class="pcalibre3 calibre11 pcalibre4">html</code> 拥有 getter 与 setter ，委托了元素自身的 <code class="pcalibre3 calibre11 pcalibre4">innerHTML</code> 方法。该访问器属性被创建在 <code class="pcalibre3 calibre11 pcalibre4">CustomHTMLElement.prototype</code> 上，并且像其他类属性那样被创建为不可枚举属性。非类的等价表示如下：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-title">// 直接等价于上个范例</span>
<span class="hljs-keyword">let</span> CustomHTMLElement = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="calibre19">
    "use strict"</span>;

    <span class="hljs-keyword">const</span> CustomHTMLElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>{

        <span class="hljs-title">// 确认函数被调用时使用了 new</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span>.target === <span class="hljs-string">"undefined"</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-params">Error</span>(<span class="hljs-string">"Constructor must be called with new."</span>);
        }

        <span class="hljs-keyword">this</span>.element = element;
    }

    <span class="hljs-params">Object</span>.defineProperty(CustomHTMLElement.prototype, <span class="hljs-string">"html"</span>, {
        enumerable: <span class="hljs-params">false</span>,
        configurable: <span class="hljs-params">true</span>,
        get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.element.innerHTML;
        },
        set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
            <span class="hljs-keyword">this</span>.element.innerHTML = value;
        }
    });

    <span class="hljs-keyword">return</span> CustomHTMLElement;
}());
</code></pre>
<p class="calibre6">正如之前的例子，此例说明了使用类语法能够少写大量的代码。仅仅为 <code class="pcalibre3 calibre11 pcalibre4">html</code> 访问器属性定义的代码量，就几乎相当于等价的类声明的全部代码量了。</p>
<h3 id="需计算的成员名" class="calibre15"><span id="computed-member-names" class="calibre13">需计算的成员名</span></h3>
<p class="calibre6">对象字面量与类之间的相似点还不仅前面那些。类方法与类访问器属性也都能使用需计算的名称。语法相同于对象字面量中的需计算名称：无须使用标识符，而是用方括号来包裹一个表达式。例如：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-keyword">let</span> methodName = <span class="hljs-string">"sayName"</span>;

<span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonClass</span> </span>{

    <span class="hljs-keyword">constructor</span>(name) {
        <span class="hljs-keyword">this</span>.name = name;
    }

    [methodName]() {
        <span class="hljs-params">console</span>.log(<span class="hljs-keyword">this</span>.name);
    }
}

<span class="hljs-keyword">let</span> me = <span class="hljs-keyword">new</span> PersonClass(<span class="hljs-string">"Nicholas"</span>);
me.sayName();           <span class="hljs-title">// "Nicholas"</span>
</code></pre>
<p class="calibre6">此版本的 <code class="pcalibre3 calibre11 pcalibre4">PersonClass</code> 使用了一个变量来命名类定义内的方法。字符串 <code class="pcalibre3 calibre11 pcalibre4">"sayName"</code> 被赋值给了 <code class="pcalibre3 calibre11 pcalibre4">methodName</code> 变量，而 <code class="pcalibre3 calibre11 pcalibre4">methodName</code> 变量则被用于声明方法。 <code class="pcalibre3 calibre11 pcalibre4">sayName()</code> 方法在此后能被直接访问。</p>
<p class="calibre6">访问器属性能以相同方式使用需计算的名称，就像这样：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-keyword">let</span> propertyName = <span class="hljs-string">"html"</span>;

<span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomHTMLElement</span> </span>{

    <span class="hljs-keyword">constructor</span>(element) {
        <span class="hljs-keyword">this</span>.element = element;
    }

    get [propertyName]() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.element.innerHTML;
    }

    set [propertyName](value) {
        <span class="hljs-keyword">this</span>.element.innerHTML = value;
    }
}
</code></pre>
<p class="calibre6">此处 <code class="pcalibre3 calibre11 pcalibre4">html</code> 的 getter 与 setter 被设置为需使用 <code class="pcalibre3 calibre11 pcalibre4">propertyName</code> 变量，使用 <code class="pcalibre3 calibre11 pcalibre4">.html</code> 依然能访问此属性，这里影响的只有定义方式。</p>
<p class="calibre6">你已经看到了在类与对象字面量之间有许多相似点，包括方法、访问器属性、需计算的名称。此外还有一个相似点需要介绍，即生成器。</p>
<h3 id="生成器方法" class="calibre15"><span id="generator-methods" class="calibre13">生成器方法</span></h3>
<p class="calibre6">第八章介绍了生成器，你已学会如何在对象字面量上定义一个生成器：只要在方法名称前附加一个星号（ <code class="pcalibre3 calibre11 pcalibre4">*</code> ）。这一语法对类同样有效，允许将任何方法变为一个生成器。此处有个范例：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{

    *createIterator() {
        <span class="hljs-keyword">yield</span> <span class="hljs-params">1</span>;
        <span class="hljs-keyword">yield</span> <span class="hljs-params">2</span>;
        <span class="hljs-keyword">yield</span> <span class="hljs-params">3</span>;
    }

}

<span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> MyClass();
<span class="hljs-keyword">let</span> iterator = instance.createIterator();
</code></pre>
<p class="calibre6">此代码创建了一个拥有 <code class="pcalibre3 calibre11 pcalibre4">createIterator()</code> 生成器的 <code class="pcalibre3 calibre11 pcalibre4">MyClass</code> 类。该方法返回了一个迭代器，它的值在生成器内部用硬编码提供。当你使用一个对象来表示值的集合、并要求能简单迭代这些值，那么生成器方法就非常有用。数组、 Set 与 Map 都拥有多个生成器方法，负责让开发者用多种方式来操作它们的项。</p>
<p class="calibre6">既然生成器方法很有用，那么在表示集合的自定义类中定义一个默认迭代器，那就更好。你可以使用 <code class="pcalibre3 calibre11 pcalibre4">Symbol.iterator</code> 来定义生成器方法，从而定义出类的默认迭代器，就像这样：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Collection</span> </span>{

    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-keyword">this</span>.items = [];
    }

    *[<span class="hljs-params">Symbol</span>.iterator]() {
        <span class="hljs-keyword">yield</span> *<span class="hljs-keyword">this</span>.items.values();
    }
}

<span class="hljs-keyword">var</span> collection = <span class="hljs-keyword">new</span> Collection();
collection.items.push(<span class="hljs-params">1</span>);
collection.items.push(<span class="hljs-params">2</span>);
collection.items.push(<span class="hljs-params">3</span>);

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> collection) {
    <span class="hljs-params">console</span>.log(x);
}

<span class="hljs-title">// 输出：</span>
<span class="hljs-title">// 1</span>
<span class="hljs-title">// 2</span>
<span class="hljs-title">// 3</span>
</code></pre>
<p class="calibre6">此例为生成器方法使用了一个需计算名称，并将此方法委托到 <code class="pcalibre3 calibre11 pcalibre4">this.items</code> 数组的 <code class="pcalibre3 calibre11 pcalibre4">values()</code> 迭代器上。任意管理集合的类都包含一个默认迭代器，这是因为一些集合专用的操作都要求目标集合具有迭代器。现在， <code class="pcalibre3 calibre11 pcalibre4">Collection</code> 的任意实例都可以在 <code class="pcalibre3 calibre11 pcalibre4">for-of</code> 循环内被直接使用，也能配合扩展运算符使用。</p>
<p class="calibre6">当你想让方法与访问器属性在对象实例上出现时，把它们添加到类的原型上就会对此目的有帮助。而另一方面，若想让方法与访问器属性只存在于类自身，那么你就需要使用静态成员。</p>
<h3 id="静态成员" class="calibre15"><span id="static-members" class="calibre13">静态成员</span></h3>
<p class="calibre6">直接在构造器上添加额外方法来模拟静态成员，这在 ES5 及更早版本中是另一个通用的模式。例如：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PersonType</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">this</span>.name = name;
}

<span class="hljs-title">// 静态方法</span>
PersonType.create = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PersonType(name);
};

<span class="hljs-title">// 实例方法</span>
PersonType.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-params">console</span>.log(<span class="hljs-keyword">this</span>.name);
};

<span class="hljs-keyword">var</span> person = PersonType.create(<span class="hljs-string">"Nicholas"</span>);
</code></pre>
<p class="calibre6">在其他编程语言中，工厂方法 <code class="pcalibre3 calibre11 pcalibre4">PersonType.create()</code> 会被认定为一个静态方法，它的数据不依赖 <code class="pcalibre3 calibre11 pcalibre4">PersonType</code> 的任何实例。 ES6 的类简化了静态成员的创建，只要在方法与访问器属性的名称前添加正式的 <code class="pcalibre3 calibre11 pcalibre4">static</code> 标注。作为一个例子，此处有个与上例等价的类：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonClass</span> </span>{

    <span class="hljs-title">// 等价于 PersonType 构造器</span>
    <span class="hljs-keyword">constructor</span>(name) {
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-title">// 等价于 PersonType.prototype.sayName</span>
    sayName() {
        <span class="hljs-params">console</span>.log(<span class="hljs-keyword">this</span>.name);
    }

    <span class="hljs-title">// 等价于 PersonType.create</span>
    <span class="hljs-keyword">static</span> create(name) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PersonClass(name);
    }
}

<span class="hljs-keyword">let</span> person = PersonClass.create(<span class="hljs-string">"Nicholas"</span>);
</code></pre>
<p class="calibre6"><code class="pcalibre3 calibre11 pcalibre4">PersonClass</code> 的定义拥有名为 <code class="pcalibre3 calibre11 pcalibre4">create()</code> 的单个静态方法，此语法与 <code class="pcalibre3 calibre11 pcalibre4">sayName()</code> 基本相同，只多了一个 <code class="pcalibre3 calibre11 pcalibre4">static</code> 关键字。你能在类中的任何方法与访问器属性上使用 <code class="pcalibre3 calibre11 pcalibre4">static</code> 关键字，唯一限制是不能将它用于 <code class="pcalibre3 calibre11 pcalibre4">constructor</code> 方法的定义。</p>
<blockquote class="calibre20">
<p class="calibre6">静态成员不能用实例来访问，你始终需要直接用类自身来访问它们。</p>
</blockquote>
<h3 id="使用派生类进行继承" class="calibre15"><span id="inheritance-with-derived-classes" class="calibre13">使用派生类进行继承</span></h3>
<p class="calibre6">ES6 之前，实现自定义类型的继承是个繁琐的过程。严格的继承要求有多个步骤。例如，研究以下范例：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params">length, width</span>) </span>{
    <span class="hljs-keyword">this</span>.length = length;
    <span class="hljs-keyword">this</span>.width = width;
}

Rectangle.prototype.getArea = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.length * <span class="hljs-keyword">this</span>.width;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Square</span>(<span class="hljs-params">length</span>) </span>{
    Rectangle.call(<span class="hljs-keyword">this</span>, length, length);
}

Square.prototype = <span class="hljs-params">Object</span>.create(Rectangle.prototype, {
    <span class="hljs-keyword">constructor</span>: {
        value:Square,
        enumerable: <span class="hljs-params">true</span>,
        writable: <span class="hljs-params">true</span>,
        configurable: <span class="hljs-params">true</span>
    }
});

<span class="hljs-keyword">var</span> square = <span class="hljs-keyword">new</span> Square(<span class="hljs-params">3</span>);

<span class="hljs-params">console</span>.log(square.getArea());              <span class="hljs-title">// 9</span>
<span class="hljs-params">console</span>.log(square <span class="hljs-keyword">instanceof</span> Square);      <span class="hljs-title">// true</span>
<span class="hljs-params">console</span>.log(square <span class="hljs-keyword">instanceof</span> Rectangle);   <span class="hljs-title">// true</span>
</code></pre>
<p class="calibre6"><code class="pcalibre3 calibre11 pcalibre4">Square</code> 继承了 <code class="pcalibre3 calibre11 pcalibre4">Rectangle</code> ，为此它必须使用 <code class="pcalibre3 calibre11 pcalibre4">Rectangle.prototype</code> 所创建的一个新对象来重写 <code class="pcalibre3 calibre11 pcalibre4">Square.prototype</code> ，并且还要调用 <code class="pcalibre3 calibre11 pcalibre4">Rectangle.call()</code> 方法。这些步骤常常会搞晕 JS 的新手，并会成为有经验开发者出错的根源之一。</p>
<p class="calibre6">类让继承工作变得更轻易，使用熟悉的 <code class="pcalibre3 calibre11 pcalibre4">extends</code> 关键字来指定当前类所需要继承的函数，即可。生成的类的原型会被自动调整，而你还能调用 <code class="pcalibre3 calibre11 pcalibre4">super()</code> 方法来访问基类的构造器。此处是与上个例子等价的 ES6 代码：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> </span>{
    <span class="hljs-keyword">constructor</span>(length, width) {
        <span class="hljs-keyword">this</span>.length = length;
        <span class="hljs-keyword">this</span>.width = width;
    }

    getArea() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.length * <span class="hljs-keyword">this</span>.width;
    }
}

<span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> </span>{
    <span class="hljs-keyword">constructor</span>(length) {

        <span class="hljs-title">// 与 Rectangle.call(this, length, length) 相同</span>
        <span class="hljs-keyword">super</span>(length, length);
    }
}

<span class="hljs-keyword">var</span> square = <span class="hljs-keyword">new</span> Square(<span class="hljs-params">3</span>);

<span class="hljs-params">console</span>.log(square.getArea());              <span class="hljs-title">// 9</span>
<span class="hljs-params">console</span>.log(square <span class="hljs-keyword">instanceof</span> Square);      <span class="hljs-title">// true</span>
<span class="hljs-params">console</span>.log(square <span class="hljs-keyword">instanceof</span> Rectangle);   <span class="hljs-title">// true</span>
</code></pre>
<p class="calibre6">此次 <code class="pcalibre3 calibre11 pcalibre4">Square</code> 类使用了 <code class="pcalibre3 calibre11 pcalibre4">extends</code> 关键字继承了 <code class="pcalibre3 calibre11 pcalibre4">Rectangle</code> 。 <code class="pcalibre3 calibre11 pcalibre4">Square</code> 构造器使用了 <code class="pcalibre3 calibre11 pcalibre4">super()</code> 配合指定参数调用了 <code class="pcalibre3 calibre11 pcalibre4">Rectangle</code> 的构造器。注意与 ES5 版本的代码不同， <code class="pcalibre3 calibre11 pcalibre4">Rectangle</code> 标识符仅在类定义时被使用了（在 <code class="pcalibre3 calibre11 pcalibre4">extends</code> 之后）。</p>
<p class="calibre6">继承了其他类的类被称为<strong class="calibre8">派生类</strong>（ <strong class="calibre8">derived classes</strong> ）。如果派生类指定了构造器，就需要使用 <code class="pcalibre3 calibre11 pcalibre4">super()</code> ，否则会造成错误。若你选择不使用构造器， <code class="pcalibre3 calibre11 pcalibre4">super()</code> 方法会被自动调用，并会使用创建新实例时提供的所有参数。例如，下列两个类是完全相同的：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> </span>{
    <span class="hljs-title">// 没有构造器</span>
}

<span class="hljs-title">// 等价于：</span>

<span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> </span>{
    <span class="hljs-keyword">constructor</span>(...args) {
        <span class="hljs-keyword">super</span>(...args);
    }
}
</code></pre>
<p class="calibre6">此例中的第二个类展示了与所有派生类默认构造器等价的写法，所有的参数都按顺序传递给了基类的构造器。在当前需求下，这种做法并不完全准确，因为 <code class="pcalibre3 calibre11 pcalibre4">Square</code> 构造器只需要单个参数，因此最好手动定义构造器。</p>
<blockquote class="calibre20">
<p class="calibre6">使用 <code class="pcalibre3 calibre11 pcalibre4">super()</code> 时需牢记以下几点：</p>
<ol class="calibre2">
<li class="calibre10">你只能在派生类中使用 <code class="pcalibre3 calibre11 pcalibre4">super()</code> 。若尝试在非派生的类（即：没有使用 <code class="pcalibre3 calibre11 pcalibre4">extends</code> 关键字的类）或函数中使用它，就会抛出错误。</li>
<li class="calibre10">在构造器中，你必须在访问 <code class="pcalibre3 calibre11 pcalibre4">this</code> 之前调用 <code class="pcalibre3 calibre11 pcalibre4">super()</code> 。由于 <code class="pcalibre3 calibre11 pcalibre4">super()</code> 负责初始化 <code class="pcalibre3 calibre11 pcalibre4">this</code> ，因此试图先访问 <code class="pcalibre3 calibre11 pcalibre4">this</code> 自然就会造成错误。</li>
<li class="calibre10">唯一能避免调用 <code class="pcalibre3 calibre11 pcalibre4">super()</code> 的办法，是从类构造器中返回一个对象。</li>
</ol>
</blockquote>
<h4 id="屏蔽类方法" class="calibre15"><span id="shadowing-class-methods" class="calibre13">屏蔽类方法</span></h4>
<p class="calibre6">派生类中的方法总是会屏蔽基类的同名方法。例如，你可以将 <code class="pcalibre3 calibre11 pcalibre4">getArea()</code> 方法添加到 <code class="pcalibre3 calibre11 pcalibre4">Square</code> 类，以便重定义它的功能：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> </span>{
    <span class="hljs-keyword">constructor</span>(length) {
        <span class="hljs-keyword">super</span>(length, length);
    }

    <span class="hljs-title">// 重写并屏蔽 Rectangle.prototype.getArea()</span>
    getArea() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.length * <span class="hljs-keyword">this</span>.length;
    }
}
</code></pre>
<p class="calibre6">由于 <code class="pcalibre3 calibre11 pcalibre4">getArea()</code> 已经被定义为 <code class="pcalibre3 calibre11 pcalibre4">Square</code> 的一部分， <code class="pcalibre3 calibre11 pcalibre4">Rectangle.prototype.getArea()</code> 方法就不能在 <code class="pcalibre3 calibre11 pcalibre4">Square</code> 的任何实例上被调用。当然，你总是可以使用 <code class="pcalibre3 calibre11 pcalibre4">super.getArea()</code> 方法来调用基类中的同名方法，就像这样：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> </span>{
    <span class="hljs-keyword">constructor</span>(length) {
        <span class="hljs-keyword">super</span>(length, length);
    }

    <span class="hljs-title">// 重写、屏蔽并调用了 Rectangle.prototype.getArea()</span>
    getArea() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getArea();
    }
}
</code></pre>
<p class="calibre6">用这种方式使用 <code class="pcalibre3 calibre11 pcalibre4">super</code> ，其效果等同于第四章讨论过的 super 引用（详见“使用 super 引用的简单原型访问”）。 <code class="pcalibre3 calibre11 pcalibre4">this</code> 值会被自动设置为正确的值，因此你就能进行简单的调用。</p>
<h4 id="继承静态成员" class="calibre15"><span id="inherited-static-members" class="calibre13">继承静态成员</span></h4>
<p class="calibre6">如果基类包含静态成员，那么这些静态成员在派生类中也是可用的。继承的工作方式类似于其他语言，但对于 JS 而言则是新概念。此处有个范例：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> </span>{
    <span class="hljs-keyword">constructor</span>(length, width) {
        <span class="hljs-keyword">this</span>.length = length;
        <span class="hljs-keyword">this</span>.width = width;
    }

    getArea() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.length * <span class="hljs-keyword">this</span>.width;
    }

    <span class="hljs-keyword">static</span> create(length, width) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Rectangle(length, width);
    }
}

<span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> </span>{
    <span class="hljs-keyword">constructor</span>(length) {

        <span class="hljs-title">// 与 Rectangle.call(this, length, length) 相同</span>
        <span class="hljs-keyword">super</span>(length, length);
    }
}

<span class="hljs-keyword">var</span> rect = Square.create(<span class="hljs-params">3</span>, <span class="hljs-params">4</span>);

<span class="hljs-params">console</span>.log(rect <span class="hljs-keyword">instanceof</span> Rectangle);     <span class="hljs-title">// true</span>
<span class="hljs-params">console</span>.log(rect.getArea());                <span class="hljs-title">// 12</span>
<span class="hljs-params">console</span>.log(rect <span class="hljs-keyword">instanceof</span> Square);        <span class="hljs-title">// false</span>
</code></pre>
<p class="calibre6">在此代码中，一个新的静态方法 <code class="pcalibre3 calibre11 pcalibre4">create()</code> 被添加到 <code class="pcalibre3 calibre11 pcalibre4">Rectangle</code> 类中。通过继承，该方法会以 <code class="pcalibre3 calibre11 pcalibre4">Square.create()</code> 的形式存在，并且其行为方式与 <code class="pcalibre3 calibre11 pcalibre4">Rectangle.create()</code> 一样。</p>
<h4 id="从表达式中派生类" class="calibre15"><span id="derived-classes-from-expressions" class="calibre13">从表达式中派生类</span></h4>
<p class="calibre6">在 ES6 中派生类的最强大能力，或许就是能够从表达式中派生类。只要一个表达式能够返回一个具有 <code class="pcalibre3 calibre11 pcalibre4">[[Construct]]</code> 属性以及原型的函数，你就可以对其使用 <code class="pcalibre3 calibre11 pcalibre4">extends</code> 。例如：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params">length, width</span>) </span>{
    <span class="hljs-keyword">this</span>.length = length;
    <span class="hljs-keyword">this</span>.width = width;
}

Rectangle.prototype.getArea = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.length * <span class="hljs-keyword">this</span>.width;
};

<span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> </span>{
    <span class="hljs-keyword">constructor</span>(length) {
        <span class="hljs-keyword">super</span>(length, length);
    }
}

<span class="hljs-keyword">var</span> x = <span class="hljs-keyword">new</span> Square(<span class="hljs-params">3</span>);
<span class="hljs-params">console</span>.log(x.getArea());               <span class="hljs-title">// 9</span>
<span class="hljs-params">console</span>.log(x <span class="hljs-keyword">instanceof</span> Rectangle);    <span class="hljs-title">// true</span>
</code></pre>
<p class="calibre6"><code class="pcalibre3 calibre11 pcalibre4">Rectangle</code> 被定义为 ES5 风格的构造器，而 <code class="pcalibre3 calibre11 pcalibre4">Square</code> 则是一个类。由于 <code class="pcalibre3 calibre11 pcalibre4">Rectangle</code> 具有 <code class="pcalibre3 calibre11 pcalibre4">[[Construct]]</code> 以及原型， <code class="pcalibre3 calibre11 pcalibre4">Square</code> 类就能直接继承它。</p>
<p class="calibre6"><code class="pcalibre3 calibre11 pcalibre4">extends</code> 后面能接受任意类型的表达式，这带来了巨大可能性，例如动态地决定所要继承的类：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params">length, width</span>) </span>{
    <span class="hljs-keyword">this</span>.length = length;
    <span class="hljs-keyword">this</span>.width = width;
}

Rectangle.prototype.getArea = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.length * <span class="hljs-keyword">this</span>.width;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBase</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> Rectangle;
}

<span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">getBase</span>() </span>{
    <span class="hljs-keyword">constructor</span>(length) {
        <span class="hljs-keyword">super</span>(length, length);
    }
}

<span class="hljs-keyword">var</span> x = <span class="hljs-keyword">new</span> Square(<span class="hljs-params">3</span>);
<span class="hljs-params">console</span>.log(x.getArea());               <span class="hljs-title">// 9</span>
<span class="hljs-params">console</span>.log(x <span class="hljs-keyword">instanceof</span> Rectangle);    <span class="hljs-title">// true</span>
</code></pre>
<p class="calibre6"><code class="pcalibre3 calibre11 pcalibre4">getBase()</code> 函数作为类声明的一部分被直接调用，它返回了 <code class="pcalibre3 calibre11 pcalibre4">Rectangle</code> ，使得此例的功能等价于前一个例子。并且由于可以动态地决定基类，那也就能创建不同的继承方式。例如，你可以有效地创建混入：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-keyword">let</span> SerializableMixin = {
    serialize() {
        <span class="hljs-keyword">return</span> <span class="hljs-params">JSON</span>.stringify(<span class="hljs-keyword">this</span>);
    }
};

<span class="hljs-keyword">let</span> AreaMixin = {
    getArea() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.length * <span class="hljs-keyword">this</span>.width;
    }
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mixin</span>(<span class="hljs-params">...mixins</span>) </span>{
    <span class="hljs-keyword">var</span> base = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{};
    <span class="hljs-params">Object</span>.assign(base.prototype, ...mixins);
    <span class="hljs-keyword">return</span> base;
}

<span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">mixin</span>(<span class="hljs-title">AreaMixin</span>, <span class="hljs-title">SerializableMixin</span>) </span>{
    <span class="hljs-keyword">constructor</span>(length) {
        <span class="hljs-keyword">super</span>();
        <span class="hljs-keyword">this</span>.length = length;
        <span class="hljs-keyword">this</span>.width = length;
    }
}

<span class="hljs-keyword">var</span> x = <span class="hljs-keyword">new</span> Square(<span class="hljs-params">3</span>);
<span class="hljs-params">console</span>.log(x.getArea());               <span class="hljs-title">// 9</span>
<span class="hljs-params">console</span>.log(x.serialize());             <span class="hljs-title">// "{"length":3,"width":3}"</span>
</code></pre>
<p class="calibre6">此例使用了混入（ mixin ）而不是传统继承。 <code class="pcalibre3 calibre11 pcalibre4">mixin()</code> 函数接受代表混入对象的任意数量的参数，它创建了一个名为 <code class="pcalibre3 calibre11 pcalibre4">base</code> 的函数，并将每个混入对象的属性都赋值到新函数的原型上。此函数随后被返回，于是 <code class="pcalibre3 calibre11 pcalibre4">Square</code> 就能够对其使用 <code class="pcalibre3 calibre11 pcalibre4">extends</code> 关键字了。注意由于仍然使用了 <code class="pcalibre3 calibre11 pcalibre4">extends</code> ，你就必须在构造器内调用 <code class="pcalibre3 calibre11 pcalibre4">super()</code> 。</p>
<p class="calibre6"><code class="pcalibre3 calibre11 pcalibre4">Square</code> 的实例既有来自 <code class="pcalibre3 calibre11 pcalibre4">AreaMixin</code> 的 <code class="pcalibre3 calibre11 pcalibre4">getArea()</code> 方法，又有来自 <code class="pcalibre3 calibre11 pcalibre4">SerializableMixin</code> 的 <code class="pcalibre3 calibre11 pcalibre4">serialize()</code> 方法，这是通过原型继承实现的。 <code class="pcalibre3 calibre11 pcalibre4">mixin()</code> 函数使用了混入对象的所有自有属性，动态地填充了新函数的原型（记住：若多个混入对象拥有相同的属性，则只有最后添加的属性会被保留）。</p>
<blockquote class="calibre20">
<p class="calibre6">任意表达式都能在 <code class="pcalibre3 calibre11 pcalibre4">extends</code> 关键字后使用，但并非所有表达式的结果都是一个有效的类。特别的，下列表达式类型会导致错误：</p>
<ul class="calibre9">
<li class="calibre10"><code class="pcalibre3 calibre11 pcalibre4">null</code> ；</li>
<li class="calibre10">生成器函数（详见第八章）。</li>
</ul>
<p class="calibre6">试图使用结果为上述值的表达式来创建一个新的类实例，都会抛出错误，因为不存在 <code class="pcalibre3 calibre11 pcalibre4">[[Construct]]</code> 可供调用。</p>
</blockquote>
<h4 id="继承内置对象" class="calibre15"><span id="inheriting-from-built-ins" class="calibre13">继承内置对象</span></h4>
<p class="calibre6">几乎从 JS 数组出现那天开始，开发者就想通过继承机制来创建他们自己的特殊数组类型。在 ES5 及早期版本中，这是不可能做到的。试图使用传统继承并不能产生功能正确的代码，例如：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-title">// 内置数组的行为</span>
<span class="hljs-keyword">var</span> colors = [];
colors[<span class="hljs-params">0</span>] = <span class="hljs-string">"red"</span>;
<span class="hljs-params">console</span>.log(colors.length);         <span class="hljs-title">// 1</span>

colors.length = <span class="hljs-params">0</span>;
<span class="hljs-params">console</span>.log(colors[<span class="hljs-params">0</span>]);             <span class="hljs-title">// undefined</span>

<span class="hljs-title">// 在 ES5 中尝试继承数组</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyArray</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-params">Array</span>.apply(<span class="hljs-keyword">this</span>, <span class="hljs-params">arguments</span>);
}

MyArray.prototype = <span class="hljs-params">Object</span>.create(<span class="hljs-params">Array</span>.prototype, {
    <span class="hljs-keyword">constructor</span>: {
        value: MyArray,
        writable: <span class="hljs-params">true</span>,
        configurable: <span class="hljs-params">true</span>,
        enumerable: <span class="hljs-params">true</span>
    }
});

<span class="hljs-keyword">var</span> colors = <span class="hljs-keyword">new</span> MyArray();
colors[<span class="hljs-params">0</span>] = <span class="hljs-string">"red"</span>;
<span class="hljs-params">console</span>.log(colors.length);         <span class="hljs-title">// 0</span>

colors.length = <span class="hljs-params">0</span>;
<span class="hljs-params">console</span>.log(colors[<span class="hljs-params">0</span>]);             <span class="hljs-title">// "red"</span>
</code></pre>
<p class="calibre6"><code class="pcalibre3 calibre11 pcalibre4">console.log()</code> 在此代码尾部的输出说明了：对数组使用传统形式的 JS 继承，产生了预期外的行为。 <code class="pcalibre3 calibre11 pcalibre4">MyArray</code> 实例上的 <code class="pcalibre3 calibre11 pcalibre4">length</code> 属性以及数值属性，其行为与内置数组并不一致，因为这些功能并未被涵盖在 <code class="pcalibre3 calibre11 pcalibre4">Array.apply()</code> 或数组原型中。</p>
<p class="calibre6">在 ES6 中的类，其设计目的之一就是允许从内置对象上进行继承。为了达成这个目的，类的继承模型与 ES5 或更早版本的传统继承模型有轻微差异，体现在以下两个重要方面：</p>
<ul class="calibre9">
<li class="calibre10">在 ES5 的传统继承中， <code class="pcalibre3 calibre11 pcalibre4">this</code> 的值会先被派生类（例如 <code class="pcalibre3 calibre11 pcalibre4">MyArray</code> ）创建，随后基类构造器（例如 <code class="pcalibre3 calibre11 pcalibre4">Array.apply()</code> 方法）才被调用。这意味着 <code class="pcalibre3 calibre11 pcalibre4">this</code> 一开始就是 <code class="pcalibre3 calibre11 pcalibre4">MyArray</code> 的实例，之后才使用了 <code class="pcalibre3 calibre11 pcalibre4">Array</code> 的附加属性对其进行了装饰。</li>
<li class="calibre10">在 ES6 基于类的继承中， <code class="pcalibre3 calibre11 pcalibre4">this</code> 的值会先被基类（ <code class="pcalibre3 calibre11 pcalibre4">Array</code> ）创建，随后才被派生类的构造器（ <code class="pcalibre3 calibre11 pcalibre4">MyArray</code> ）所修改。结果是 <code class="pcalibre3 calibre11 pcalibre4">this</code> 初始就拥有作为基类的内置对象的所有功能，并能正确接收与之关联的所有功能。</li>
</ul>
<p class="calibre6">以下范例实际展示了基于类的特殊数组：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Array</span> </span>{
    <span class="hljs-title">// 空代码块</span>
}

<span class="hljs-keyword">var</span> colors = <span class="hljs-keyword">new</span> MyArray();
colors[<span class="hljs-params">0</span>] = <span class="hljs-string">"red"</span>;
<span class="hljs-params">console</span>.log(colors.length);         <span class="hljs-title">// 1</span>

colors.length = <span class="hljs-params">0</span>;
<span class="hljs-params">console</span>.log(colors[<span class="hljs-params">0</span>]);             <span class="hljs-title">// undefined</span>
</code></pre>
<p class="calibre6"><code class="pcalibre3 calibre11 pcalibre4">MyArray</code> 直接继承了 <code class="pcalibre3 calibre11 pcalibre4">Array</code> ，因此工作方式与正规数组一致。与数值索引属性的互动更新了 <code class="pcalibre3 calibre11 pcalibre4">length</code> 属性，而操纵 <code class="pcalibre3 calibre11 pcalibre4">length</code> 属性也能更新索引属性。这意味着你既能适当地继承 <code class="pcalibre3 calibre11 pcalibre4">Array</code> 来创建你自己的派生数组类，也同样能继承其他的内置对象。伴随着这些附加功能， ES6 与派生类型有效解决了从内置类型进行派生这最后的特殊情况，不过这种情况仍然值得继续探索。</p>
<h4 id="symbolspecies-属性" class="calibre15"><span id="the-symbol-species-property" class="calibre13">Symbol.species 属性</span></h4>
<p class="calibre6">继承内置对象一个有趣的方面是：任意能返回内置对象实例的方法，在派生类上却会自动返回派生类的实例。因此，若你拥有一个继承了 <code class="pcalibre3 calibre11 pcalibre4">Array</code> 的派生类 <code class="pcalibre3 calibre11 pcalibre4">MyArray</code> ，诸如 <code class="pcalibre3 calibre11 pcalibre4">slice()</code> 之类的方法都会返回 <code class="pcalibre3 calibre11 pcalibre4">MyArray</code> 的实例。例如：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Array</span> </span>{
    <span class="hljs-title">// 空代码块</span>
}

<span class="hljs-keyword">let</span> items = <span class="hljs-keyword">new</span> MyArray(<span class="hljs-params">1</span>, <span class="hljs-params">2</span>, <span class="hljs-params">3</span>, <span class="hljs-params">4</span>),
    subitems = items.slice(<span class="hljs-params">1</span>, <span class="hljs-params">3</span>);

<span class="hljs-params">console</span>.log(items <span class="hljs-keyword">instanceof</span> MyArray);      <span class="hljs-title">// true</span>
<span class="hljs-params">console</span>.log(subitems <span class="hljs-keyword">instanceof</span> MyArray);   <span class="hljs-title">// true</span>
</code></pre>
<p class="calibre6">在此代码中， <code class="pcalibre3 calibre11 pcalibre4">slice()</code> 方法返回了 <code class="pcalibre3 calibre11 pcalibre4">MyArray</code> 的一个实例。 <code class="pcalibre3 calibre11 pcalibre4">slice()</code> 方法是从 <code class="pcalibre3 calibre11 pcalibre4">Array</code> 上继承的，原本应当返回 <code class="pcalibre3 calibre11 pcalibre4">Array</code> 的一个实例。而 <code class="pcalibre3 calibre11 pcalibre4">Symbol.species</code> 属性在后台造成了这种变化。</p>
<p class="calibre6"><code class="pcalibre3 calibre11 pcalibre4">Symbol.species</code> 知名符号被用于定义一个能返回函数的静态访问器属性。每当类实例的方法（构造器除外）必须创建一个实例时，前面返回的函数就被用为新实例的构造器。下列内置类型都定义了 <code class="pcalibre3 calibre11 pcalibre4">Symbol.species</code> ：</p>
<ul class="calibre9">
<li class="calibre10"><code class="pcalibre3 calibre11 pcalibre4">Array</code></li>
<li class="calibre10"><code class="pcalibre3 calibre11 pcalibre4">ArrayBuffer</code> （详见第十章）</li>
<li class="calibre10"><code class="pcalibre3 calibre11 pcalibre4">Map</code></li>
<li class="calibre10"><code class="pcalibre3 calibre11 pcalibre4">Promise</code></li>
<li class="calibre10"><code class="pcalibre3 calibre11 pcalibre4">RegExp</code></li>
<li class="calibre10"><code class="pcalibre3 calibre11 pcalibre4">Set</code></li>
<li class="calibre10">类型化数组（详见第十章）</li>
</ul>
<p class="calibre6">以上每个类型都拥有默认的 <code class="pcalibre3 calibre11 pcalibre4">Symbol.species</code> 属性，其返回值为 <code class="pcalibre3 calibre11 pcalibre4">this</code> ，意味着该属性总是会返回自身的构造器函数。若你准备在一个自定义类上实现此功能，代码就像这样：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-title">// 几个内置类型使用 species 的方式类似于此</span>
<span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-keyword">static</span> get [<span class="hljs-params">Symbol</span>.species]() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    <span class="hljs-keyword">constructor</span>(value) {
        <span class="hljs-keyword">this</span>.value = value;
    }

    clone() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.constructor[<span class="hljs-params">Symbol</span>.species](<span class="hljs-keyword">this</span>.value);
    }
}
</code></pre>
<p class="calibre6">在此例中， <code class="pcalibre3 calibre11 pcalibre4">Symbol.species</code> 知名符号被用于定义 <code class="pcalibre3 calibre11 pcalibre4">MyClass</code> 的一个静态访问器属性。注意此处只有 getter 而没有 setter ，这是因为修改类的 species 是不允许的。任何对 <code class="pcalibre3 calibre11 pcalibre4">this.constructor[Symbol.species]</code> 的调用都会返回 <code class="pcalibre3 calibre11 pcalibre4">MyClass</code> ， <code class="pcalibre3 calibre11 pcalibre4">clone()</code> 方法使用了该定义来返回一个新的实例，而没有直接使用 <code class="pcalibre3 calibre11 pcalibre4">MyClass</code> ，这就允许派生类重写这个值。例如：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-keyword">static</span> get [<span class="hljs-params">Symbol</span>.species]() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    <span class="hljs-keyword">constructor</span>(value) {
        <span class="hljs-keyword">this</span>.value = value;
    }

    clone() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.constructor[<span class="hljs-params">Symbol</span>.species](<span class="hljs-keyword">this</span>.value);
    }
}

<span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDerivedClass1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-title">// 空代码块</span>
}

<span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDerivedClass2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-keyword">static</span> get [<span class="hljs-params">Symbol</span>.species]() {
        <span class="hljs-keyword">return</span> MyClass;
    }
}

<span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> MyDerivedClass1(<span class="hljs-string">"foo"</span>),
    clone1 = instance1.clone(),
    instance2 = <span class="hljs-keyword">new</span> MyDerivedClass2(<span class="hljs-string">"bar"</span>),
    clone2 = instance2.clone();

<span class="hljs-params">console</span>.log(clone1 <span class="hljs-keyword">instanceof</span> MyClass);             <span class="hljs-title">// true</span>
<span class="hljs-params">console</span>.log(clone1 <span class="hljs-keyword">instanceof</span> MyDerivedClass1);     <span class="hljs-title">// true</span>
<span class="hljs-params">console</span>.log(clone2 <span class="hljs-keyword">instanceof</span> MyClass);             <span class="hljs-title">// true</span>
<span class="hljs-params">console</span>.log(clone2 <span class="hljs-keyword">instanceof</span> MyDerivedClass2);     <span class="hljs-title">// false</span>
</code></pre>
<p class="calibre6">此处, <code class="pcalibre3 calibre11 pcalibre4">MyDerivedClass1</code> 继承了 <code class="pcalibre3 calibre11 pcalibre4">MyClass</code> ，并且未修改 <code class="pcalibre3 calibre11 pcalibre4">Symbol.species</code> 属性。由于 <code class="pcalibre3 calibre11 pcalibre4">this.constructor[Symbol.species]</code> 会返回 <code class="pcalibre3 calibre11 pcalibre4">MyDerivedClass1</code> ，当 <code class="pcalibre3 calibre11 pcalibre4">clone()</code> 被调用时，它就返回了 <code class="pcalibre3 calibre11 pcalibre4">MyDerivedClass1</code> 的一个实例。 <code class="pcalibre3 calibre11 pcalibre4">MyDerivedClass2</code> 类也继承了 <code class="pcalibre3 calibre11 pcalibre4">MyClass</code> ，但重写了 <code class="pcalibre3 calibre11 pcalibre4">Symbol.species</code> ，让其返回 <code class="pcalibre3 calibre11 pcalibre4">MyClass</code> 。当 <code class="pcalibre3 calibre11 pcalibre4">clone()</code> 在 <code class="pcalibre3 calibre11 pcalibre4">MyDerivedClass2</code> 的一个实例上被调用时，返回值就变成 <code class="pcalibre3 calibre11 pcalibre4">MyClass</code> 的一个实例。使用 <code class="pcalibre3 calibre11 pcalibre4">Symbol.species</code> ，任意派生类在调用应当返回实例的方法时，都可以判断出需要返回什么类型的值。</p>
<p class="calibre6">例如， <code class="pcalibre3 calibre11 pcalibre4">Array</code> 使用了 <code class="pcalibre3 calibre11 pcalibre4">Symbol.species</code> 来指定方法所使用的类，让其返回值为一个数组。在 <code class="pcalibre3 calibre11 pcalibre4">Array</code> 派生出的类中，你可以决定这些继承的方法应返回何种类型的对象，正如：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Array</span> </span>{
    <span class="hljs-keyword">static</span> get [<span class="hljs-params">Symbol</span>.species]() {
        <span class="hljs-keyword">return</span> <span class="hljs-params">Array</span>;
    }
}

<span class="hljs-keyword">let</span> items = <span class="hljs-keyword">new</span> MyArray(<span class="hljs-params">1</span>, <span class="hljs-params">2</span>, <span class="hljs-params">3</span>, <span class="hljs-params">4</span>),
    subitems = items.slice(<span class="hljs-params">1</span>, <span class="hljs-params">3</span>);

<span class="hljs-params">console</span>.log(items <span class="hljs-keyword">instanceof</span> MyArray);      <span class="hljs-title">// true</span>
<span class="hljs-params">console</span>.log(subitems <span class="hljs-keyword">instanceof</span> <span class="hljs-params">Array</span>);     <span class="hljs-title">// true</span>
<span class="hljs-params">console</span>.log(subitems <span class="hljs-keyword">instanceof</span> MyArray);   <span class="hljs-title">// false</span>
</code></pre>
<p class="calibre6">此代码重写了从 <code class="pcalibre3 calibre11 pcalibre4">Array</code> 派生的 <code class="pcalibre3 calibre11 pcalibre4">MyArray</code> 类上的 <code class="pcalibre3 calibre11 pcalibre4">Symbol.species</code> 。所有返回数组的继承方法现在都会使用 <code class="pcalibre3 calibre11 pcalibre4">Array</code> 的实例，而不是 <code class="pcalibre3 calibre11 pcalibre4">MyArray</code> 的实例。</p>
<p class="calibre6">一般而言，每当想在类方法中使用 <code class="pcalibre3 calibre11 pcalibre4">this.constructor</code> 时，你就应当设置类的 <code class="pcalibre3 calibre11 pcalibre4">Symbol.species</code> 属性。这么做允许派生类轻易地重写方法的返回类型。此外，若你从一个拥有 <code class="pcalibre3 calibre11 pcalibre4">Symbol.species</code> 定义的类创建了派生类，要保证使用此属性，而不是直接使用构造器。</p>
<h3 id="在类构造器中使用-newtarget" class="calibre15"><span id="using-new-target-in-class-constructors" class="calibre13">在类构造器中使用 new.target</span></h3>
<p class="calibre6">在第三章你已学到了 <code class="pcalibre3 calibre11 pcalibre4">new.target</code> ，以及在调用函数的方式不同时它的值是如何变动的。你也可以在类构造器中使用 <code class="pcalibre3 calibre11 pcalibre4">new.target</code> ，来判断类是被如何被调用的。在简单情况下， <code class="pcalibre3 calibre11 pcalibre4">new.target</code> 就等于本类的构造器函数，正如下例；</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> </span>{
    <span class="hljs-keyword">constructor</span>(length, width) {
        <span class="hljs-params">console</span>.log(<span class="hljs-keyword">new</span>.target === Rectangle);
        <span class="hljs-keyword">this</span>.length = length;
        <span class="hljs-keyword">this</span>.width = width;
    }
}

<span class="hljs-title">// new.target 就是 Rectangle</span>
<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-params">3</span>, <span class="hljs-params">4</span>);      <span class="hljs-title">// 输出 true</span>
</code></pre>
<p class="calibre6">此代码说明在 <code class="pcalibre3 calibre11 pcalibre4">new Rectangle(3, 4)</code> 被调用时， <code class="pcalibre3 calibre11 pcalibre4">new.target</code> 就等于 <code class="pcalibre3 calibre11 pcalibre4">Rectangle</code> 。类构造器被调用时不能缺少 <code class="pcalibre3 calibre11 pcalibre4">new</code> ，因此 <code class="pcalibre3 calibre11 pcalibre4">new.target</code> 属性就始终会在类构造器内被定义。不过这个值并不总是相同的。研究以下代码：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> </span>{
    <span class="hljs-keyword">constructor</span>(length, width) {
        <span class="hljs-params">console</span>.log(<span class="hljs-keyword">new</span>.target === Rectangle);
        <span class="hljs-keyword">this</span>.length = length;
        <span class="hljs-keyword">this</span>.width = width;
    }
}

<span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> </span>{
    <span class="hljs-keyword">constructor</span>(length) {
        <span class="hljs-keyword">super</span>(length, length)
    }
}

<span class="hljs-title">// new.target 就是 Square</span>
<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Square(<span class="hljs-params">3</span>);      <span class="hljs-title">// 输出 false</span>
</code></pre>
<p class="calibre6"><code class="pcalibre3 calibre11 pcalibre4">Square</code> 调用了 <code class="pcalibre3 calibre11 pcalibre4">Rectangle</code> 构造器，因此当 <code class="pcalibre3 calibre11 pcalibre4">Rectangle</code> 构造器被调用时， <code class="pcalibre3 calibre11 pcalibre4">new.target</code> 等于 <code class="pcalibre3 calibre11 pcalibre4">Square</code> 。这很重要，因为构造器能根据如何被调用而有不同行为，并且这给了更改这种行为的能力。例如，你可以使用 <code class="pcalibre3 calibre11 pcalibre4">new.target</code> 来创建一个抽象基类（一种不能被实例化的类），如下：</p>
<pre class="calibre16"><code class="lang-javascript pcalibre6 pcalibre5"><span class="hljs-title">// 静态的基类</span>
<span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>.target === Shape) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-params">Error</span>(<span class="hljs-string">"This class cannot be instantiated directly."</span>)
        }
    }
}

<span class="calibre19"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>{
    <span class="hljs-keyword">constructor</span>(length, width) {
        <span class="hljs-keyword">super</span>();
        <span class="hljs-keyword">this</span>.length = length;
        <span class="hljs-keyword">this</span>.width = width;
    }
}

<span class="hljs-keyword">var</span> x = <span class="hljs-keyword">new</span> Shape();                <span class="hljs-title">// 抛出错误</span>

<span class="hljs-keyword">var</span> y = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-params">3</span>, <span class="hljs-params">4</span>);        <span class="hljs-title">// 没有错误</span>
<span class="hljs-params">console</span>.log(y <span class="hljs-keyword">instanceof</span> Shape);    <span class="hljs-title">// true</span>
</code></pre>
<p class="calibre6">此例中的 <code class="pcalibre3 calibre11 pcalibre4">Shape</code> 类构造器会在 <code class="pcalibre3 calibre11 pcalibre4">new.target</code> 为 <code class="pcalibre3 calibre11 pcalibre4">Shape</code> 的时候抛出错误，意味着 <code class="pcalibre3 calibre11 pcalibre4">new Shape()</code> 永远都会抛出错误。然而，你依然可以将 <code class="pcalibre3 calibre11 pcalibre4">Shape</code> 用作一个基类，正如 <code class="pcalibre3 calibre11 pcalibre4">Rectangle</code> 所做的那样。 <code class="pcalibre3 calibre11 pcalibre4">super()</code> 的调用执行了 <code class="pcalibre3 calibre11 pcalibre4">Shape</code> 构造器，而且 <code class="pcalibre3 calibre11 pcalibre4">new.target</code> 的值等于 <code class="pcalibre3 calibre11 pcalibre4">Rectangle</code> ，因此该构造器能够无错误地继续执行。</p>
<blockquote class="calibre20">
<p class="calibre6">由于调用类时不能缺少 <code class="pcalibre3 calibre11 pcalibre4">new</code> ，于是 <code class="pcalibre3 calibre11 pcalibre4">new.target</code> 属性在类构造器内部就绝不会是 <code class="pcalibre3 calibre11 pcalibre4">undefined</code> 。</p>
</blockquote>
<h3 id="总结" class="calibre15"><span id="summary" class="calibre13">总结</span></h3>
<p class="calibre6">ES6 的类让 JS 中的继承变得更简单，因此对于你已从其他语言学习到的类知识，你无须将其丢弃。 ES6 的类起初是作为 ES5 传统继承模型的语法糖，但添加了许多特性来减少错误。</p>
<p class="calibre6">ES6 的类配合原型继承来工作，在类的原型上定义了非静态的方法，而静态的方法最终则被绑定在类构造器自身上。类的所有方法初始都是不可枚举的，这更契合了内置对象的行为，后者的方法默认情况下通常都不可枚举。此外，类构造器被调用时不能缺少 <code class="pcalibre3 calibre11 pcalibre4">new</code> ，确保了不能意外地将类作为函数来调用。</p>
<p class="calibre6">基于类的继承允许你从另一个类、函数或表达式上派生新的类。这种能力意味着你可以调用一个函数来判断需要继承的正确基类，也允许你使用混入或其他不同的组合模式来创建一个新类。新的继承方式让继承内置对象（例如数组）也变为可能，并且其工作符合预期。</p>
<p class="calibre6">你可以在类构造器内部使用 <code class="pcalibre3 calibre11 pcalibre4">new.target</code> ，以便根据类如何被调用来做出不同的行为。最常用的就是创建一个抽象基类，直接实例化它会抛出错误，但它仍然允许被其他类所继承。</p>
<p class="calibre6">总之，类是 JS 的一项新特性，它提供了更简洁的语法与更好的功能，通过安全一致的方式来自定义一个对象类型。</p>

        </div>
    
</div>

        
    


</body></html>
